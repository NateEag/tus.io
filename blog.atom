<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="https://tus.io/blog.atom" rel="self" type="application/atom+xml" /><link href="https://tus.io/" rel="alternate" type="text/html" /><updated>2022-07-26T07:51:27+02:00</updated><id>https://tus.io/blog.atom</id><entry><title type="html">Towards tus 2.0</title><link href="https://tus.io/blog/2022/02/24/tus-v2.html" rel="alternate" type="text/html" title="Towards tus 2.0" /><published>2022-02-24T00:00:00+01:00</published><updated>2022-02-24T00:00:00+01:00</updated><id>https://tus.io/blog/2022/02/24/tus-v2</id><content type="html" xml:base="https://tus.io/blog/2022/02/24/tus-v2.html"><![CDATA[<p>Seven years ago, in November 2015, <a href="/blog/2015/11/16/tus.1.0.html">we announced the release of tus 1.0</a>, the first major and stable version of our uploading protocol. In the past months, we have been actively working on the next steps for tus and wanted to share early details about <strong>tus 2.0</strong>.</p>

<p>tus 2.0 will keep the same principles and approaches for how uploads are performed. This ensures that upgrading the uploading infrastructure from tus 1.0 to 2.0 is as seamless as possible for the end-users as well as for the developers. The most important changes will happen to the structure of the protocol:</p>

<p>The <a href="/protocols/resumable-upload.html">specification of tus 1.0</a> consists of the core uploading protocol and multiple optional extensions, such as the creation extension, termination extension, and checksum extension. All of these specifications have been hosted on our website <a href="/">tus.io</a> and we have been pleased to see a <a href="/implementations.html">wide variety of implementations</a>, in part because it is based on open standards like HTTP.</p>

<p>Looking to the future, we'd like to further encourage native implementations of the uploading protocol in browsers and mobile platform SDKs, as well making resumable uploads accessible to more people. To that end, we would like <strong>tus 2.0</strong>, to be an open standard. In considering how to approach standardization, we believe that turning the core uploading protocol into a clear and concise standard within the <a href="https://www.ietf.org/">IETF</a> is most appropriate. We have published a <a href="https://datatracker.ietf.org/doc/draft-tus-httpbis-resumable-uploads-protocol/">first revision of an Internet-Draft</a> and are engaging with the process of formal adoption into a suitable venue at the IETF.</p>

<h2 id="what-will-change-between-tus-10-and-20">What will change between tus 1.0 and 2.0?</h2>

<p>tus 2.0 will keep the same uploading approach and most functionality. The most important changes will happen to the structure of the protocol:</p>

<p>The <a href="/protocols/resumable-upload.html">specification of tus 1.0</a> consists of the core uploading protocol and multiple optional extensions, such as the creation extension, termination extension, and checksum extension. Our major goal with tus 2.0 is to turn the core uploading protocol into an <a href="https://www.ietf.org/">IETF</a> Internet Standard. The tus protocol will still be open and freely accessible and usable, but with a more formal standard.</p>

<p>Features that currently exist as optional extensions in tus 1.0 might not be part of the standardized upload protocol. These features will also be included in tus 2.0 as optional extensions, that live outside the standardized upload protocol. This helps ensure that the standardized upload protocol is concise and focused, while also continuing to support additional use cases.</p>

<h2 id="what-is-the-current-status-of-tus-20">What is the current status of tus 2.0?</h2>

<p>As of the time of writing, we are actively working on the core uploading protocol, which will seek adoption and standardization of in the IETF. You can see the current draft at <a href="https://tus.github.io/tus-v2/draft-tus-httpbis-resumable-uploads-protocol.html">tus.github.io/tus-v2</a> and join the discussion in our GitHub repository at <a href="https://github.com/tus/tus-v2">github.com/tus/tus-v2</a>. We have published a <a href="https://datatracker.ietf.org/doc/draft-tus-httpbis-resumable-uploads-protocol/">first revision of an Internet-Draft</a> and are engaging with the process of formal adoption into a suitable venue at the IETF. Work on additional tus 2.0 extensions, that will cover the content from tus 1.0 that will not be included in the standardized upload protocol, has not been started yet.</p>

<h2 id="what-will-happen-to-the-client-and-server-implementations">What will happen to the client and server implementations?</h2>

<p>For all of our <a href="/implementations.html">official implementations</a>, we are going to add support for tus 2.0 while also keeping support for tus 1.0. This ensures a seamless upgrade to tus 2.0 while also supporting existing users of tus 1.0.</p>

<p>So far, <a href="https://github.com/tus/tusd/pull/568">tusd</a> and <a href="https://github.com/tusdotnet/tusdotnet/tree/POC/tus2">tusdotnet</a> contain experimental support for tus 2.0. These might change however as the tus 2.0 specification matures.</p>

<h2 id="can-i-contribute-to-tus-20">Can I contribute to tus 2.0?</h2>

<p>Yes, of course! Many details of tus 2.0 are not settled in stone yet. You can always check out the current state and join the discussion in our <a href="https://github.com/tus/tus-v2">GitHub repository</a>.</p>

<h2 id="thank-you-to-all-contributors">Thank you to all contributors</h2>

<p>A grateful “Thank You” goes especially to <a href="https://github.com/guoye-zhang">Guoye Zhang</a>, <a href="https://github.com/jitenmehta">Jiten Mehta</a>, <a href="https://github.com/justinruggles">Justin Ruggles</a>, <a href="https://github.com/LPardue">Lucas Pardue</a>, and <a href="https://github.com/smatsson">Stefan Matsson</a>. All of them have dedicated their time and efforts into working on tus 2.0. Thank you all!</p>]]></content><author><name>Marius Kleidl</name><email>marius@transloadit.com</email></author><summary type="html"><![CDATA[Seven years ago, in November 2015, we announced the release of tus 1.0, the first major and stable version of our uploading protocol. In the past months, we have been actively working on the next steps for tus and wanted to share early details about tus 2.0. tus 2.0 will keep the same principles and approaches for how uploads are performed. This ensures that upgrading the uploading infrastructure from tus 1.0 to 2.0 is as seamless as possible for the end-users as well as for the developers. The most important changes will happen to the structure of the protocol: The specification of tus 1.0 consists of the core uploading protocol and multiple optional extensions, such as the creation extension, termination extension, and checksum extension. All of these specifications have been hosted on our website tus.io and we have been pleased to see a wide variety of implementations, in part because it is based on open standards like HTTP. Looking to the future, we'd like to further encourage native implementations of the uploading protocol in browsers and mobile platform SDKs, as well making resumable uploads accessible to more people. To that end, we would like tus 2.0, to be an open standard. In considering how to approach standardization, we believe that turning the core uploading protocol into a clear and concise standard within the IETF is most appropriate. We have published a first revision of an Internet-Draft and are engaging with the process of formal adoption into a suitable venue at the IETF. What will change between tus 1.0 and 2.0? tus 2.0 will keep the same uploading approach and most functionality. The most important changes will happen to the structure of the protocol: The specification of tus 1.0 consists of the core uploading protocol and multiple optional extensions, such as the creation extension, termination extension, and checksum extension. Our major goal with tus 2.0 is to turn the core uploading protocol into an IETF Internet Standard. The tus protocol will still be open and freely accessible and usable, but with a more formal standard. Features that currently exist as optional extensions in tus 1.0 might not be part of the standardized upload protocol. These features will also be included in tus 2.0 as optional extensions, that live outside the standardized upload protocol. This helps ensure that the standardized upload protocol is concise and focused, while also continuing to support additional use cases. What is the current status of tus 2.0? As of the time of writing, we are actively working on the core uploading protocol, which will seek adoption and standardization of in the IETF. You can see the current draft at tus.github.io/tus-v2 and join the discussion in our GitHub repository at github.com/tus/tus-v2. We have published a first revision of an Internet-Draft and are engaging with the process of formal adoption into a suitable venue at the IETF. Work on additional tus 2.0 extensions, that will cover the content from tus 1.0 that will not be included in the standardized upload protocol, has not been started yet. What will happen to the client and server implementations? For all of our official implementations, we are going to add support for tus 2.0 while also keeping support for tus 1.0. This ensures a seamless upgrade to tus 2.0 while also supporting existing users of tus 1.0. So far, tusd and tusdotnet contain experimental support for tus 2.0. These might change however as the tus 2.0 specification matures. Can I contribute to tus 2.0? Yes, of course! Many details of tus 2.0 are not settled in stone yet. You can always check out the current state and join the discussion in our GitHub repository. Thank you to all contributors A grateful “Thank You” goes especially to Guoye Zhang, Jiten Mehta, Justin Ruggles, Lucas Pardue, and Stefan Matsson. All of them have dedicated their time and efforts into working on tus 2.0. Thank you all!]]></summary></entry><entry><title type="html">Uploading files to Azure Storage using tusd</title><link href="https://tus.io/blog/2021/08/10/tusd-azure-storage.html" rel="alternate" type="text/html" title="Uploading files to Azure Storage using tusd" /><published>2021-08-10T00:00:00+02:00</published><updated>2021-08-10T00:00:00+02:00</updated><id>https://tus.io/blog/2021/08/10/tusd-azure-storage</id><content type="html" xml:base="https://tus.io/blog/2021/08/10/tusd-azure-storage.html"><![CDATA[<p>Today we are excited to announce that <a href="https://github.com/tus/tusd">tusd</a> is now also able to store uploaded files in the Azure Cloud Storage! Just like all tus servers, tusd's role is to accept incoming uploads from the tus clients and then relay them to the underlying storage providers. For a long time has tusd already supported storing uploads locally on disk, on AWS S3 and Google's Cloud Storage. Thanks to an incredible contribution from <a href="https://github.com/omBratteng">Ole-Martin Bratteng</a>, this support has been expanded to also cover the Azure Cloud Storage!</p>

<h2 id="on-the-backend">On the backend</h2>

<p>The Azure Blob Storage implementation is only supporting the Block Blob. This was a concious choice to make the implementation easier to use, and is the most fitting blob type for tusd. The current service version supported is <code>2019-12-12</code>, which allows files up to 190.7 TiB in size (4000 MiB x 50,000 blocks).</p>

<p>Upon starting tusd with Azure Blob Storage as the selected storage endpoint, it will atempt to connect to a container (also known as a Bucket in S3). If one does not exist, it will be created. You can also specify the access type of the container, which defaults to private, and the default blob access tier type which defaults to the inferred tier from the storage account.</p>

<p>When tusd receives a chunk of data from the client, it will stage the chunk as a block in the Azure Blob Storage. When the client sends the last chunk of data, tusd will then send commit the block list to the Azure Blob Storage, which in part, creates the file in the Azure Blob Storage.</p>

<p>We've also implemented support for <a href="https://github.com/Azure/Azurite">Azurite</a>, which is a lightweight, self-hosted Azure Blob Storage emulator, this can be enabled by using the <code>-azure-endpoint</code> flag. This should also work for custom Azure Blob Storage endpoints, although it has not been tested fully.</p>

<h2 id="give-it-a-try">Give it a try</h2>

<p>Support for Azure Cloud Storage is part of the <a href="https://github.com/tus/tusd/releases/tag/v1.7.1">v1.7.1 release</a>, where the prebuilt binaries can be downloaded. Give this new feature a try and let us know on <a href="https://github.com/tus/tusd/issues">GitHub</a> if you encounter any problems!</p>

<p>To conclude this blog post, let's again thank <a href="https://github.com/omBratteng">Ole-Martin Bratteng</a> for this amazing contribution!</p>]]></content><author><name>Marius Kleidl</name><email>marius@transloadit.com</email></author><summary type="html"><![CDATA[Today we are excited to announce that tusd is now also able to store uploaded files in the Azure Cloud Storage! Just like all tus servers, tusd's role is to accept incoming uploads from the tus clients and then relay them to the underlying storage providers. For a long time has tusd already supported storing uploads locally on disk, on AWS S3 and Google's Cloud Storage. Thanks to an incredible contribution from Ole-Martin Bratteng, this support has been expanded to also cover the Azure Cloud Storage! On the backend The Azure Blob Storage implementation is only supporting the Block Blob. This was a concious choice to make the implementation easier to use, and is the most fitting blob type for tusd. The current service version supported is 2019-12-12, which allows files up to 190.7 TiB in size (4000 MiB x 50,000 blocks). Upon starting tusd with Azure Blob Storage as the selected storage endpoint, it will atempt to connect to a container (also known as a Bucket in S3). If one does not exist, it will be created. You can also specify the access type of the container, which defaults to private, and the default blob access tier type which defaults to the inferred tier from the storage account. When tusd receives a chunk of data from the client, it will stage the chunk as a block in the Azure Blob Storage. When the client sends the last chunk of data, tusd will then send commit the block list to the Azure Blob Storage, which in part, creates the file in the Azure Blob Storage. We've also implemented support for Azurite, which is a lightweight, self-hosted Azure Blob Storage emulator, this can be enabled by using the -azure-endpoint flag. This should also work for custom Azure Blob Storage endpoints, although it has not been tested fully. Give it a try Support for Azure Cloud Storage is part of the v1.7.1 release, where the prebuilt binaries can be downloaded. Give this new feature a try and let us know on GitHub if you encounter any problems! To conclude this blog post, let's again thank Ole-Martin Bratteng for this amazing contribution!]]></summary></entry><entry><title type="html">Announcing the tus Advisory Group</title><link href="https://tus.io/blog/2020/11/12/tus-advisory-group.html" rel="alternate" type="text/html" title="Announcing the tus Advisory Group" /><published>2020-11-12T00:00:00+01:00</published><updated>2020-11-12T00:00:00+01:00</updated><id>https://tus.io/blog/2020/11/12/tus-advisory-group</id><content type="html" xml:base="https://tus.io/blog/2020/11/12/tus-advisory-group.html"><![CDATA[<p>Since the tus project began in 2013, countless contributors with various technical backgrounds have joined our mission and helped move the protocol forward. Many people have contributed their knowledge to tus over these years, some as front-end developers and server engineers, and others as security professionals or network administrators. This variety is of great importance as it allows us to look at problems from different angles and find the optimal solution for everyone involved. Furthermore, since we want the tus protocol to be available and usable for many applications, it's essential to get feedback from as many people as possible.</p>

<p>To ensure that we do not lose this variety and to avoid living in our own technical bubble, we have formed the <strong>tus Advisory Group</strong>. Our approach has always been that important decisions about the future of the project must always be preceded by input from multiple people with different backgrounds, since these decisions have the potential to impact many applications and organizations. Questions and proposals must be discussed in the open, so everyone who is willing to take part in the conversation has the opportunity to do so.</p>

<p>That's where the tus Advisory Group comes in! It consists of contributors from the community who would like to be more engaged with the protocol and shape its further development. The group's members will discuss fundamental questions about the direction that tus should take in the future. Of course, all of those conversations will always be open and available for everyone to join! The Advisory Group is not a closed circle but instead a formation that will be invited to weigh in on all major discussions regarding tus.</p>

<p>As of writing this, the group consists of: <a href="https://github.com/smatsson">Stefan Matsson</a>, the person behind <a href="https://github.com/tusdotnet/tusdotnet">tusdotnet</a>; <a href="https://github.com/nigoroll">Nils Goroll</a>, who we can thank for the <a href="https://code.uplex.de/uplex-varnish/libvmod-tus">tus Varnish Cache module</a>; and <a href="https://github.com/Acconut">Marius Kleidl</a>, who currently leads the tus project. We hope that by forming this group, we can keep our high level of variety and ensure further development of the tus project in such a way that it benefits as many people as possible!</p>

<p>If you are interested in joining the Advisory Group or want to get more involved in the project, feel free to <a href="/support.html">reach out to us</a>!</p>]]></content><author><name>Marius Kleidl</name><email>marius@transloadit.com</email></author><summary type="html"><![CDATA[Since the tus project began in 2013, countless contributors with various technical backgrounds have joined our mission and helped move the protocol forward. Many people have contributed their knowledge to tus over these years, some as front-end developers and server engineers, and others as security professionals or network administrators. This variety is of great importance as it allows us to look at problems from different angles and find the optimal solution for everyone involved. Furthermore, since we want the tus protocol to be available and usable for many applications, it's essential to get feedback from as many people as possible. To ensure that we do not lose this variety and to avoid living in our own technical bubble, we have formed the tus Advisory Group. Our approach has always been that important decisions about the future of the project must always be preceded by input from multiple people with different backgrounds, since these decisions have the potential to impact many applications and organizations. Questions and proposals must be discussed in the open, so everyone who is willing to take part in the conversation has the opportunity to do so. That's where the tus Advisory Group comes in! It consists of contributors from the community who would like to be more engaged with the protocol and shape its further development. The group's members will discuss fundamental questions about the direction that tus should take in the future. Of course, all of those conversations will always be open and available for everyone to join! The Advisory Group is not a closed circle but instead a formation that will be invited to weigh in on all major discussions regarding tus. As of writing this, the group consists of: Stefan Matsson, the person behind tusdotnet; Nils Goroll, who we can thank for the tus Varnish Cache module; and Marius Kleidl, who currently leads the tus project. We hope that by forming this group, we can keep our high level of variety and ensure further development of the tus project in such a way that it benefits as many people as possible! If you are interested in joining the Advisory Group or want to get more involved in the project, feel free to reach out to us!]]></summary></entry><entry><title type="html">Major release: tus-js-client v2.0.0</title><link href="https://tus.io/blog/2020/05/04/tus-js-client-200.html" rel="alternate" type="text/html" title="Major release: tus-js-client v2.0.0" /><published>2020-05-04T00:00:00+02:00</published><updated>2020-05-04T00:00:00+02:00</updated><id>https://tus.io/blog/2020/05/04/tus-js-client-200</id><content type="html" xml:base="https://tus.io/blog/2020/05/04/tus-js-client-200.html"><![CDATA[<p class="lead">tus is a protocol based on HTTP for resumable file uploads. Resumable here means that an interrupted upload can carry on without re-uploading already uploaded data again. An interruption may happen willingly, if the user wants to pause while switching to another workspace, or by accident in case of an network issue or server outage. When resumability is implemented with automatic retries (with this release now the default), the user does not need to notice there was an interruption. Since HTTP/1.1 such a resumability is available for file downloads already but not for file uploads as tus offers.</p>

<p><a href="https://github.com/tus/tus-js-client/">tus-js-client</a> is the official client implementation for <a href="/protocols/resumable-upload.html">the tus protocol</a> in JavaScript. Since it had been born five years ago, it has grown enormously in numbers of features and supported environments. While it was originally designed for <strong>web browsers</strong>, it can now also be used in:</p>

<ul>
  <li><strong>Node.js</strong>,</li>
  <li><strong>React Native</strong>, and</li>
  <li><strong>Apache Cordova</strong> applications.</li>
</ul>

<p>However, over time this growth came at the cost of some technical debt which can hinder further development. In this release we cleaned up the code base, removed some odd API decisions from early stages and add long awaited features, such as <strong>Automatic Retries</strong> and <strong>Parallel Chunked Uploads</strong>. We are pleased to introduce you to the all new <strong>tus-js-client v2.0.0</strong>, which packs all this, and more.</p>

<h2 id="new-features">New features</h2>

<p>Besides cleaning up old technical debt, this release also introduces new functionality:</p>

<ul>
  <li><strong>Add support for Parallel Uploads</strong><br />
tus-js-client now supports parallel upload requests using the <a href="https://tus.io/protocols/resumable-upload.html#concatenation">Concatenation extension</a>. When enabled, an input file will be split into multiple equally sized parts which are uploaded in parallel. After all requests are finished, the parts will be stitched together on the server-side to produce the original file. The motivation behind this feature is to allow better utilization of network connections and available bandwidth. See the <a href="https://github.com/tus/tus-js-client/blob/v2.0/docs/api.md#paralleluploads"><code>parallelUploads</code> documentation</a> for more details.</li>
  <li><strong>Add Upload Storage API</strong><br />
tus-js-client was always able to resume uploads which have been started in a previous browsing session. This is possible by storing the upload resource's URL after it has been created and retrieving it from said storage based on file metadata later on. This allows users to pick up an upload where it had been left off even after the browser is (accidentally) closed. tus-js-client uses the Web Storage API to save this pointer inside the browsers but historically provided little access to retrieve or modify elements in this URL storage.
To remove this limitation, we introduce the URL Storage interface: You are now able to supply your own URL storage using the <a href="https://github.com/tus/tus-js-client/blob/v2.0/docs/api.md#urlstorage"><code>urlStorage</code> option</a>, if you want to save URLs in a database, for example.
Furthermore, you can now easily query the URL storage to retrieve a list of previously started uploads using the <a href="https://github.com/tus/tus-js-client/blob/v2.0/docs/api.md#tusuploadfindpreviousuploads"><code>findPreviousUploads</code> method</a> and ask the end user which upload should be resumed. Please have a look at <a href="https://github.com/tus/tus-js-client/blob/v2.0/docs/usage.md#example-let-user-select-upload-to-resume">the corresponding example</a> for more details on this approach.</li>
  <li><strong>Add HTTP abstraction layer</strong><br />
tus-js-client has always contained an abstraction layer to smooth out the differences between the network APIs in browsers and inside Node.js. Users now also have the ability to supply a custom HTTP stack to further customize the used HTTP interface. See the <a href="https://github.com/tus/tus-js-client/blob/v2.0/docs/api.md#httpstack"><code>httpStack</code> documentation</a> for more details.</li>
  <li><strong>Add File Reader abstraction layer</strong><br />
Similar to the HTTP abstraction layer, tus-js-client also uses an abstraction to uniformly read data from the different input file types. If you want to add support for another input type, you can supply your own file reader implementation now. See the <a href="https://github.com/tus/tus-js-client/blob/v2.0/docs/api.md#filereader"><code>fileReader</code> documentation</a> for more details.</li>
  <li><strong>Add request IDs</strong><br />
tus-js-client can now be configured to send unique request IDs using the <code>X-Request-ID</code> header. Since tus-js-client includes this ID in its error messages, it can be used to correlate client errors with server logs to make debugging easier. See the <a href="https://github.com/tus/tus-js-client/blob/v2.0/docs/api.md#addrequestid"><code>addRequestId</code> documentation</a> for more details.</li>
  <li><strong>Add request and response callbacks</strong><br />
This release also adds the <code>onBeforeRequest</code> and <code>onAfterResponse</code> callbacks which will be invoked before a HTTP request is sent and directly after a HTTP response is received. This allows you to modify outgoing requests or retrieve additional information from incoming responses. See the <a href="https://github.com/tus/tus-js-client/blob/v2.0/docs/api.md#onbeforerequest">documentation</a> for more information and examples.</li>
</ul>

<h2 id="breaking-changes">Breaking changes</h2>

<p>The main behavior of tus-js-client and the vast majority of its API surface stay the same. However, the following breaking changes were necessary:</p>

<ul>
  <li><strong>Drop support for Node.js 6 and 7</strong><br />
Only Node.js 8 or newer are fully supported and tested for compatibility with tus-js-client from now own. Earlier versions may work but we don't guarantee or support it. Please note that we still support the same browsers as before, with the exception of requiring a polyfill in some cases, explained further down.</li>
  <li><strong>Require support for Promises</strong><br />
The internal code has been partially rewritten to use Promises instead of callbacks, which allowed us to clean up a lot of old spaghetti code. For library users this means that you need to use a <em>Promise polyfill</em> if your application runs in older browsers which do not support Promises. Have a look at <a href="https://caniuse.com/#feat=promises">caniuse.com</a> for a list of those browsers and <a href="https://github.com/zloirock/core-js#ecmascript-promise">core-js</a> for a polyfill.</li>
  <li><strong>Use Promises for <code>abort</code>/<code>terminate</code> functions</strong><br />
The <code>Upload#abort</code> and <code>Upload.terminate</code> functions do not longer accept a callback but instead return a Promise now. We recommend adding a catch phrase to avoid errors about unhandled rejections. If you have code such as:
    <pre><code class="language-js">upload.abort(true, (err) =&gt; {
  if (err) // Handle error
  else // Handle successful abort call
})
</code></pre>
    <p>you should rewrite it to:</p>
    <pre><code class="language-js">upload.abort(true).then(() =&gt; {
  // Handle success
}).catch((err) =&gt; {
  // Handle error
})
</code></pre>
  </li>
  <li><strong>Use Promises for the <code>fingerprint</code> option</strong><br />
The function that is passed as the <code>fingerprint</code> option into the <code>Upload</code>-constructor is not callback-based anymore. Instead it must also return a Promise. If you supply a custom fingerprint function it must have a signature such as:
    <pre><code class="language-js">function fingerprint (file, options) {
  const result = ....
  return Promise.resolve(result)
})
</code></pre>
  </li>
  <li><strong>Enable retries by default</strong><br />
tus-js-client has supported automated retries of network-caused error for years using the <code>retryDelays</code> option. However, in order to avoid breaking changes, this feature had been disabled by default when it was introduced. With this release, the retrying mechanism will be enabled by default to make it easier for new users to take advantage of it. If you have custom retrying code implemented, you may want to check that it is compatible when tus-js-client also retries HTTP requests.</li>
  <li><strong>Remove <code>resume</code> option</strong><br />
Historically, the <code>resume</code> option has controlled whether tus-js-client will check if it is possible to resume an upload from a previous browsing session (e.g. when the browser has accidentally been closed while the upload was still running). This was implemented by calculating the fingerprint for the given input file and comparing it to a list of previously created uploads which was stored in the browser's <code>localStorage</code>. If such an upload exists, tus-js-client would attempt to resume it.
However, this effectively gives the application no control over which upload is resumed. In previous versions, applications were not able to retrieve the list of previously created uploads or remove items from this list. Furthermore, if multiple matching uploads were found for a fingerprint, the applications could not decide which of those uploads should be resumed.
In this release, the <code>resume</code> option has been removed and instead the Upload Storage API has been added. An introduction into the Upload Storage API can be found in the New Features section higher up. If you previously did not explicitly set <code>resume: false</code>, and hence relied on tus-js-client deciding to resume, you can get the previous behavior using following code snippet:
    <pre><code class="language-js">upload = new tus.Upload(file, options)
upload.findPreviousUploads().then((previousUploads) =&gt; {
  if (previousUploads.length &gt; 0) {
    upload.resumeFromPreviousUpload(previousUploads[0])
  }

  upload.start()
})
</code></pre>
    <p>or in <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">async/await</a> syntax:</p>
    <pre><code class="language-js">upload = new tus.Upload(file, options)
const previousUploads = await upload.findPreviousUploads()
if (previousUploads.length &gt; 0) {
  upload.resumeFromPreviousUpload(previousUploads[0])
}
upload.start()
</code></pre>
  </li>
  <li><strong>Remove <code>withCredentials</code> option</strong><br />
This release introduces an HTTP abstraction layer to overcome differences between network APIs in browsers and inside Node.js. This makes internal code a lot cleaner but also means that the browser-only <code>withCredentials</code> option is not properly possible anymore. If you used this feature before, you can now explicitly set this flag using the request callbacks:
    <pre><code class="language-js">upload = new tus.Upload(file, {
  endpoint: '....',
  onBeforeRequest: (req) =&gt; {
    const xhr = req.getUnderlyingObject()
    xhr.withCredentials = true
  },
  ....
})
</code></pre>
  </li>
</ul>

<h2 id="try-it">Try it</h2>

<p>If you'd like to try it out, we have updated our <a href="/demo.html">demo</a> to use tus-js-client v2.0 as well. The code for it can be found <a href="https://github.com/tus/tus.io/blob/master/assets/javascripts/upload-demo.js">here</a>. Do leave a comment there how it went!</p>

<p>Finally, we want to thank everyone who helped to make this release happen! If you also want to contribute, you can find our open source code at <a href="https://github.com/tus">GitHub</a>. If you don't know where to start or have other questions, feel free to <a href="/support.html">contact us</a>!</p>]]></content><author><name>Marius Kleidl</name><email>marius@transloadit.com</email></author><summary type="html"><![CDATA[tus is a protocol based on HTTP for resumable file uploads. Resumable here means that an interrupted upload can carry on without re-uploading already uploaded data again. An interruption may happen willingly, if the user wants to pause while switching to another workspace, or by accident in case of an network issue or server outage. When resumability is implemented with automatic retries (with this release now the default), the user does not need to notice there was an interruption. Since HTTP/1.1 such a resumability is available for file downloads already but not for file uploads as tus offers. tus-js-client is the official client implementation for the tus protocol in JavaScript. Since it had been born five years ago, it has grown enormously in numbers of features and supported environments. While it was originally designed for web browsers, it can now also be used in: Node.js, React Native, and Apache Cordova applications. However, over time this growth came at the cost of some technical debt which can hinder further development. In this release we cleaned up the code base, removed some odd API decisions from early stages and add long awaited features, such as Automatic Retries and Parallel Chunked Uploads. We are pleased to introduce you to the all new tus-js-client v2.0.0, which packs all this, and more. New features Besides cleaning up old technical debt, this release also introduces new functionality: Add support for Parallel Uploads tus-js-client now supports parallel upload requests using the Concatenation extension. When enabled, an input file will be split into multiple equally sized parts which are uploaded in parallel. After all requests are finished, the parts will be stitched together on the server-side to produce the original file. The motivation behind this feature is to allow better utilization of network connections and available bandwidth. See the parallelUploads documentation for more details. Add Upload Storage API tus-js-client was always able to resume uploads which have been started in a previous browsing session. This is possible by storing the upload resource's URL after it has been created and retrieving it from said storage based on file metadata later on. This allows users to pick up an upload where it had been left off even after the browser is (accidentally) closed. tus-js-client uses the Web Storage API to save this pointer inside the browsers but historically provided little access to retrieve or modify elements in this URL storage. To remove this limitation, we introduce the URL Storage interface: You are now able to supply your own URL storage using the urlStorage option, if you want to save URLs in a database, for example. Furthermore, you can now easily query the URL storage to retrieve a list of previously started uploads using the findPreviousUploads method and ask the end user which upload should be resumed. Please have a look at the corresponding example for more details on this approach. Add HTTP abstraction layer tus-js-client has always contained an abstraction layer to smooth out the differences between the network APIs in browsers and inside Node.js. Users now also have the ability to supply a custom HTTP stack to further customize the used HTTP interface. See the httpStack documentation for more details. Add File Reader abstraction layer Similar to the HTTP abstraction layer, tus-js-client also uses an abstraction to uniformly read data from the different input file types. If you want to add support for another input type, you can supply your own file reader implementation now. See the fileReader documentation for more details. Add request IDs tus-js-client can now be configured to send unique request IDs using the X-Request-ID header. Since tus-js-client includes this ID in its error messages, it can be used to correlate client errors with server logs to make debugging easier. See the addRequestId documentation for more details. Add request and response callbacks This release also adds the onBeforeRequest and onAfterResponse callbacks which will be invoked before a HTTP request is sent and directly after a HTTP response is received. This allows you to modify outgoing requests or retrieve additional information from incoming responses. See the documentation for more information and examples. Breaking changes The main behavior of tus-js-client and the vast majority of its API surface stay the same. However, the following breaking changes were necessary: Drop support for Node.js 6 and 7 Only Node.js 8 or newer are fully supported and tested for compatibility with tus-js-client from now own. Earlier versions may work but we don't guarantee or support it. Please note that we still support the same browsers as before, with the exception of requiring a polyfill in some cases, explained further down. Require support for Promises The internal code has been partially rewritten to use Promises instead of callbacks, which allowed us to clean up a lot of old spaghetti code. For library users this means that you need to use a Promise polyfill if your application runs in older browsers which do not support Promises. Have a look at caniuse.com for a list of those browsers and core-js for a polyfill. Use Promises for abort/terminate functions The Upload#abort and Upload.terminate functions do not longer accept a callback but instead return a Promise now. We recommend adding a catch phrase to avoid errors about unhandled rejections. If you have code such as: upload.abort(true, (err) =&gt; { if (err) // Handle error else // Handle successful abort call }) you should rewrite it to: upload.abort(true).then(() =&gt; { // Handle success }).catch((err) =&gt; { // Handle error }) Use Promises for the fingerprint option The function that is passed as the fingerprint option into the Upload-constructor is not callback-based anymore. Instead it must also return a Promise. If you supply a custom fingerprint function it must have a signature such as: function fingerprint (file, options) { const result = .... return Promise.resolve(result) }) Enable retries by default tus-js-client has supported automated retries of network-caused error for years using the retryDelays option. However, in order to avoid breaking changes, this feature had been disabled by default when it was introduced. With this release, the retrying mechanism will be enabled by default to make it easier for new users to take advantage of it. If you have custom retrying code implemented, you may want to check that it is compatible when tus-js-client also retries HTTP requests. Remove resume option Historically, the resume option has controlled whether tus-js-client will check if it is possible to resume an upload from a previous browsing session (e.g. when the browser has accidentally been closed while the upload was still running). This was implemented by calculating the fingerprint for the given input file and comparing it to a list of previously created uploads which was stored in the browser's localStorage. If such an upload exists, tus-js-client would attempt to resume it. However, this effectively gives the application no control over which upload is resumed. In previous versions, applications were not able to retrieve the list of previously created uploads or remove items from this list. Furthermore, if multiple matching uploads were found for a fingerprint, the applications could not decide which of those uploads should be resumed. In this release, the resume option has been removed and instead the Upload Storage API has been added. An introduction into the Upload Storage API can be found in the New Features section higher up. If you previously did not explicitly set resume: false, and hence relied on tus-js-client deciding to resume, you can get the previous behavior using following code snippet: upload = new tus.Upload(file, options) upload.findPreviousUploads().then((previousUploads) =&gt; { if (previousUploads.length &gt; 0) { upload.resumeFromPreviousUpload(previousUploads[0]) } upload.start() }) or in async/await syntax: upload = new tus.Upload(file, options) const previousUploads = await upload.findPreviousUploads() if (previousUploads.length &gt; 0) { upload.resumeFromPreviousUpload(previousUploads[0]) } upload.start() Remove withCredentials option This release introduces an HTTP abstraction layer to overcome differences between network APIs in browsers and inside Node.js. This makes internal code a lot cleaner but also means that the browser-only withCredentials option is not properly possible anymore. If you used this feature before, you can now explicitly set this flag using the request callbacks: upload = new tus.Upload(file, { endpoint: '....', onBeforeRequest: (req) =&gt; { const xhr = req.getUnderlyingObject() xhr.withCredentials = true }, .... }) Try it If you'd like to try it out, we have updated our demo to use tus-js-client v2.0 as well. The code for it can be found here. Do leave a comment there how it went! Finally, we want to thank everyone who helped to make this release happen! If you also want to contribute, you can find our open source code at GitHub. If you don't know where to start or have other questions, feel free to contact us!]]></summary></entry><entry><title type="html">The tusd server hits v1.0.0</title><link href="https://tus.io/blog/2019/09/20/tusd-100.html" rel="alternate" type="text/html" title="The tusd server hits v1.0.0" /><published>2019-09-20T00:00:00+02:00</published><updated>2019-09-20T00:00:00+02:00</updated><id>https://tus.io/blog/2019/09/20/tusd-100</id><content type="html" xml:base="https://tus.io/blog/2019/09/20/tusd-100.html"><![CDATA[<p>Today, we are thrilled to announce the v1.0.0 release of our <a href="https://github.com/tus/tusd">tusd project</a>, the official reference implementation for the tus protocol. Don't let yourself be fooled by the version number, tusd has been production-ready and battle-tested for many years already.</p>

<p>This release ships with a few exciting new features but most of the changes were necessary to clean up technical debt which accumulated  over the last four years. We try to avoid frequent breaking changes in tusd to reduce the impact of dependency upgrades on your project. However, this debt also prevented us from adding new highly-requested features and tusd 1.0 is now able to deliver those.</p>

<p>A detailed list of all relevant changes in the 1.0 release can be found in the <a href="https://github.com/tus/tusd/releases/tag/v1.0.0">release notes</a> where you are also able to download prebuilt binaries for Linux, macOS and Windows.</p>

<p>Despite the number of breaking changes, I want to emphasize that <strong>no changes to your tus clients</strong> are necessary. All breaking changes are server-facing only and tusd offers the same tus HTTP interface as before. This was an important guarantee for us as we want to make it easy for you to upgrade tusd without worrying about older clients.</p>

<p>Finally, I want to thank everyone again who helped to make this release happen! If you also want to contribute, you can find our open source code at <a href="https://github.com/tus">GitHub</a>. If you don't know where to start or have other questions, feel free to <a href="/support.html">contact us</a>!</p>]]></content><author><name>Marius Kleidl</name><email>marius@transloadit.com</email></author><summary type="html"><![CDATA[Today, we are thrilled to announce the v1.0.0 release of our tusd project, the official reference implementation for the tus protocol. Don't let yourself be fooled by the version number, tusd has been production-ready and battle-tested for many years already. This release ships with a few exciting new features but most of the changes were necessary to clean up technical debt which accumulated over the last four years. We try to avoid frequent breaking changes in tusd to reduce the impact of dependency upgrades on your project. However, this debt also prevented us from adding new highly-requested features and tusd 1.0 is now able to deliver those. A detailed list of all relevant changes in the 1.0 release can be found in the release notes where you are also able to download prebuilt binaries for Linux, macOS and Windows. Despite the number of breaking changes, I want to emphasize that no changes to your tus clients are necessary. All breaking changes are server-facing only and tusd offers the same tus HTTP interface as before. This was an important guarantee for us as we want to make it easy for you to upgrade tusd without worrying about older clients. Finally, I want to thank everyone again who helped to make this release happen! If you also want to contribute, you can find our open source code at GitHub. If you don't know where to start or have other questions, feel free to contact us!]]></summary></entry><entry><title type="html">React Native, Cordova and Browser Streams using tus-js-client 1.6</title><link href="https://tus.io/blog/2019/03/10/tus-js-client-160.html" rel="alternate" type="text/html" title="React Native, Cordova and Browser Streams using tus-js-client 1.6" /><published>2019-03-10T00:00:00+01:00</published><updated>2019-03-10T00:00:00+01:00</updated><id>https://tus.io/blog/2019/03/10/tus-js-client-160</id><content type="html" xml:base="https://tus.io/blog/2019/03/10/tus-js-client-160.html"><![CDATA[<p>A bit less than two months ago, we released <a href="https://github.com/tus/tus-js-client/releases/tag/v1.6.0">version 1.6.0</a> of <a href="https://github.com/tus/tus-js-client/">tus-js-client</a>, our open source tus implementation for JavaScript environments. Usually, we don't write a blog post about a specific release, but this one is very special to us for two reasons:</p>

<ol>
  <li>Version 1.6.0 contains three very exiting new features, and</li>
  <li>All of the three features were contributed by members of our community.</li>
</ol>

<p>To raise awareness about those new additions, as well as to thank the contributors for their help, I decided to write a short blog post about them. <!--more--> So, without further ado, let's jump straight in:</p>

<ul>
  <li><a href="https://github.com/paulrosenzweig">Paul Rosenzweig</a> added support for <strong>uploading streaming data</strong> inside your <strong>browser</strong> to a tus server. In the beginning, tus-js-client was only capable of uploading complete files with a pre-known size. However, in some cases you want to upload your data simultaneously while it is arriving from some other services. For example, it's nice to pipe a live-recorded video to your server in real-time. Some time ago, we added support for streaming uploads to tus-js-client inside Node.js, but Paul extended this support to cover browser environments using the new <a href="https://developer.mozilla.org/en-US/docs/Web/API/Streams_API">JavaScript Streams API</a>. For more details, you might want to look at the <a href="https://github.com/tus/tus-js-client/tree/v1.6.0#new-tusuploadfile-options">documentation</a> or its <a href="https://github.com/tus/tus-js-client/pull/126">pull request</a>.</li>
  <li>Next up is <a href="https://github.com/arturi">Artur Paikin</a> who contributed a simpler <strong>integration with React Native</strong>. It was already possible to use tus-js-client with React Native, but it required some boilerplate code. Basically, you had to resolve React Native's file URIs before you were able to upload the corresponding files. For his work on <a href="https://uppy.io/">Uppy</a> (an open source, modular and modern file uploader from the folks at <a href="https://transloadit.com">Transloadit</a>) he integrated this boilerplate into tus-js-client, so you can now pass the file URIs directly to tus-js-client without worrying about the details. You can find more details in the <a href="https://github.com/tus/tus-js-client/tree/v1.6.0#react-native-support">documentation</a> or in its <a href="https://github.com/tus/tus-js-client/pull/132">pull request</a>.</li>
  <li>Last but not least, <a href="https://github.com/hannuniemela">Hannu Niemelä</a> picked up some earlier work from <a href="https://github.com/naranjamecanica">Martijn Swart</a> and blew off some dust. Thanks to their help, you can now use tus-js-client inside your <strong>Apache Cordova application</strong>. That's the fourth platform tus-js-client supports, next to browsers, Node.js and React Native! If you're not aware, <a href="https://cordova.apache.org/">Cordova</a> allows you to create mobile, cross-platform apps using HTML, CSS and JavaScript. Even though it's similar to a browser environment, Cordova's runtime has a few differences that tus-js-client can now easily handle. More details can be found in the <a href="https://github.com/tus/tus-js-client/tree/v1.6.0#new-tusuploadfile-options">documentation</a> or in its <a href="https://github.com/tus/tus-js-client/pull/134">pull request</a>.</li>
</ul>

<p>Finally, I want to thank everyone again who helped to make this release happen! If you also want to contribute, you can find our open source code at <a href="https://github.com/tus">GitHub</a>. If you don't know where to start or have other questions, feel free to <a href="/support.html">contact us</a>!</p>]]></content><author><name>Marius Kleidl</name><email>marius@transloadit.com</email></author><summary type="html"><![CDATA[A bit less than two months ago, we released version 1.6.0 of tus-js-client, our open source tus implementation for JavaScript environments. Usually, we don't write a blog post about a specific release, but this one is very special to us for two reasons: Version 1.6.0 contains three very exiting new features, and All of the three features were contributed by members of our community. To raise awareness about those new additions, as well as to thank the contributors for their help, I decided to write a short blog post about them.]]></summary></entry><entry><title type="html">Adoption</title><link href="https://tus.io/blog/2018/09/25/adoption.html" rel="alternate" type="text/html" title="Adoption" /><published>2018-09-25T00:00:00+02:00</published><updated>2018-09-25T00:00:00+02:00</updated><id>https://tus.io/blog/2018/09/25/adoption</id><content type="html" xml:base="https://tus.io/blog/2018/09/25/adoption.html"><![CDATA[<p>Just a quick update from the team!</p>

<p>We had a fun month as we learned that <a href="https://github.com/git-lfs/git-lfs/blob/master/docs/man/git-lfs-config.5.ronn#transfer-upload--download-settings">Git LFS supports our protocol for transmitting large files</a>, and Clouflare uses it to power the uploading component of their <a href="https://blog.cloudflare.com/how-cloudflare-streams/">new streaming product</a>. The 'tus' community on GitHub continues to thrive and we're seeing issues raised and addressed on a daily basis. You guys are awesome!</p>

<!--more-->

<p>Tus was also featured in a magazine: Streaming Media. Since they were asking for supporting graphic material, we asked our designer <a href="https://twitter.com/nqst">Alexander Zaytsev</a> to explain the Concat Extension in a visual way, and he came up with the following:</p>

<p><img style="max-width: 100%; max-height: 100%" src="/assets/img/concat.jpeg" /></p>

<p>We thought it was really cool, but we also wanted to share it and hear what <em>you</em> think!</p>

<p>All the best from the team at <a href="https://transloadit.com">Transloadit</a> and see you on GitHub or the forum!</p>]]></content><author><name>Kevin van Zonneveld</name><email>kevin@transloadit.com</email></author><summary type="html"><![CDATA[Just a quick update from the team! We had a fun month as we learned that Git LFS supports our protocol for transmitting large files, and Clouflare uses it to power the uploading component of their new streaming product. The 'tus' community on GitHub continues to thrive and we're seeing issues raised and addressed on a daily basis. You guys are awesome!]]></summary></entry><entry><title type="html">How tus may help to save lives</title><link href="https://tus.io/blog/2017/05/19/how-tus-may-help-to-save-lives.html" rel="alternate" type="text/html" title="How tus may help to save lives" /><published>2017-05-19T00:00:00+02:00</published><updated>2017-05-19T00:00:00+02:00</updated><id>https://tus.io/blog/2017/05/19/how-tus-may-help-to-save-lives</id><content type="html" xml:base="https://tus.io/blog/2017/05/19/how-tus-may-help-to-save-lives.html"><![CDATA[<p>Yes, oddly enough, this seems to be the case! A while ago, we noticed something really interesting on tus.io, our open protocol for resumable uploads: a <a href="/implementations.html#comment-2903776646">comment</a> from <a href="https://twitter.com/Orajo">Jaroslaw Wasilewski</a> mentioned that tus was being used to support firefighting rescue operations. Now that is exciting news!</p>

<p>While we did set out to make the world a slightly better place by making uploading more reliable for everyone, this is certainly not what we had in mind. We were very interested to learn more about this, so we invited Jaroslaw to sit down with us for a virtual cup of coffee and asked him to tell us a little more about the system they have developed – and how they are using tus for it.</p>

<!--more-->

<div class="kodak-container kodak-dropshadow">
<img src="/assets/img/fireman.jpg" alt="Firefighters" style="width: 100%;" />
</div>

<p><strong>Could you tell us something about the work you do and the kind of service your company provides to fire fighters?</strong></p>

<blockquote>
  <p>Certainly! My name is Jaroslaw Wasilewski and I work as a developer for an IT company called <a href="http://Bit-sa.pl">BIT S.A.</a>, which is located in Bialystok, Poland. We primarily write dedicated software for government and local administration. Our fire brigades were already using a system for handling requests and directing them to the appropriate, nearest units. There was, however, nothing in place that could support communication during rescue operations, either between units or between the command center and the firefighters in the field, beyond the typical radio communication. So, we developed a set of mobile and web-based applications that allows for messages, documents, data mapping, pictures and videos from the area of action to be sent to the command post and vice versa. It also makes it possible to closely monitor both the location and status of vehicles and firefighters, and it can be used to report the state of the victims. Lastly, it even provides logistic services for long-term rescue operations, such as forest fires or other natural disasters.  The system is currently being tested by firefighters in the <a href="https://en.wikipedia.org/wiki/Podlaskie_Voivodeship">province of Podlasie</a>.</p>
</blockquote>

<p><strong>How exactly are you using tus? Could you tell me something about the way it is used in firefighting operations?</strong></p>

<blockquote>
  <p>Tus is being used to send photos, videos and  other documents from mobile application to the back-end as attachments to the exchanged messages. This allows units in the field to immediately give the command center of any rescue operation a full and clear picture of the situation at hand. Fast and reliable file uploading is something that might help to save lives in such cases and, with the help of tus, our system can provide that. A more reliable means of transferring information, even under very poor networking circumstances, means that those in charge of rescue operations are better equipped to make decisions at times when lives are at stake.</p>
</blockquote>

<p><strong>How did you find out about tus and what led you to implement the protocol in your system?</strong></p>

<blockquote>
  <p>We needed an effective solution for transferring large types of data, such as high-resolution photos and long videos. Our system was intended to operate on a GSM network, often outside the cities, in areas where coverage tends to be weak and intermittent. With that in mind, the solution should be able to upload files piece by piece and save the current upload state. We didn't want to use FTP because it would be quite difficult to integrate with the REST API and also because partial transfer can be very unreliable. Our <a href="https://netbulls.io/">subcontractor</a>, who develops the mobile parts of the system, told us about tus.  While they themselves had not used it before, it quickly appeared after some more searching for possible solutions and various tests that tus met all of our expectations. The availability of libraries for the Android and .NET platforms was also crucially important for us. Furthermore, thanks to the tusd server and JavaScript client we had a great reference solution for the analysis of the protocol. As a result, we were able to prepare a new implementation of the tus server for PHP, and in parallel, work on the mobile application.</p>
</blockquote>

<p><strong>Did you encounter any challenges in implementing tus? If so, how did you overcome them?</strong></p>

<blockquote>
  <p>At that time, the biggest problem was the lack of documentation for version 1.0 of tus. The only available documentation concerned, from what I remember, version 0.2. Therefore, much of our work had to be based on tests and analysis of HTTP messages from the <a href="/demo.html">demo version</a>. That said, thanks to the availability of the tusd server, our subcontractor managed to complete all of their preparations before I'd finished my work. That was a great help. And when the <a href="/protocols/resumable-upload.html">tus protocol 1.0</a> was released, I was able to fix some remaining issues.</p>
</blockquote>

<p><strong>What benefits have the fire departments you work with experienced after tus was implemented?</strong></p>

<blockquote>
  <p>After several months of intensive testing of the system, we can say that the transfer of files has been very reliable - not a single damaged file has been reported! For that part, we owe a big thanks to tus. As a result, the fire departments that are currently testing this system have had a much more robust and reliable system of communication to their disposal – and something like that can certainly save lives in emergency situations.</p>
</blockquote>

<p>Thanks a lot to Jaroslaw for taking the time to answer our questions about this fascinating use case for tus! Our primary motivation behind the development of tus has been a desire to change the way the world does file uploading. So, with that in mind, you can imagine our excitement when we learned that the protocol was already being trusted with the communications of emergency services. To us, this really stands as a testament to its reliability.</p>

<p>We hope that by sharing this story, more companies and developers might be tempted to give tus a try. After all, the more people that start using this protocol, the sooner truly reliable, resumable uploads can become a reality for all of us. If you’d like to know more about this specific use for tus, or about the protocol in general, feel free to <a href="https://twitter.com/tus_io">reach out</a>! And if you are also using tus for something interesting, we’d love to hear about that as well!</p>]]></content><author><name>A.J. van Loon</name></author><summary type="html"><![CDATA[Yes, oddly enough, this seems to be the case! A while ago, we noticed something really interesting on tus.io, our open protocol for resumable uploads: a comment from Jaroslaw Wasilewski mentioned that tus was being used to support firefighting rescue operations. Now that is exciting news! While we did set out to make the world a slightly better place by making uploading more reliable for everyone, this is certainly not what we had in mind. We were very interested to learn more about this, so we invited Jaroslaw to sit down with us for a virtual cup of coffee and asked him to tell us a little more about the system they have developed – and how they are using tus for it.]]></summary></entry><entry><title type="html">S3 as a Storage Back-End</title><link href="https://tus.io/blog/2016/03/07/tus-s3-backend.html" rel="alternate" type="text/html" title="S3 as a Storage Back-End" /><published>2016-03-07T00:00:00+01:00</published><updated>2016-03-07T00:00:00+01:00</updated><id>https://tus.io/blog/2016/03/07/tus-s3-backend</id><content type="html" xml:base="https://tus.io/blog/2016/03/07/tus-s3-backend.html"><![CDATA[<p>With their Simple Storage System (S3), Amazon Web Services has built one of the major providers of cloud storage for applications ranging from small side projects to enterprise systems. Since the introduction of flexible storage back-ends for the official <a href="https://github.com/tus/tusd">tusd</a> server, an integration with S3 has been a much desired feature by our users. We are happy to announce that we are now able to <a href="https://pkg.go.dev/github.com/tus/tusd@v1.6.0/pkg/s3store">deliver</a> on this request. During the time it took to create this, we had to deal with various peculiarities of Amazon's service and were able to gain a lot of experience. In this post, we want to focus on the downsides of building a tus server on top of S3 and share some of our recently acquired knowledge with you.</p>

<!--more-->

<h2 id="immutable-objects">Immutable Objects</h2>

<p>We, as the designers of tus, have to admit that the protocol uses a data model which is mostly incompatible with AWS S3. In order to understand this sentence, we need to make a small comparison: In tus, when you want to move a file to a remote location, you first create a new upload resource without pushing any of the file's data to the server. It is even possible to make this operation before you know the length or size of the entire object that you want to transfer. After this step, you are free to upload the data in chunks of any size. The first chunk could be a few MBs, followed by one that is just 100 bytes and a final upload then contains the remaining GB. While this freedom introduces the need for a flexible server implementation, which is capable of handling chunks of any size, it also lays the foundation for tus' core feature: <strong>resumability of an upload at any given time</strong>.</p>

<p>S3, however, does not offer this flexibility: once an object - the length of which must also be known beforehand – has been uploaded to a specific location, you are unable to modify its content without transmitting the entire new file. It is simply not possible to add a chunk to an existing object without having to perform additional operations. It may sound, then, as if the main requirement of the tus protocol is not met by Amazon's service, but that is not the case. You are certainly able to build a proper server implementation for tus, as long as you are willing to accept certain restrictions. This can, for instance, be seen in the <a href="https://godoc.org/github.com/tus/tusd/pkg/s3store">S3 storage back-end</a> for the <a href="https://github.com/tus/tusd">tusd</a> server.</p>

<h2 id="multipart-uploads">Multipart Uploads</h2>

<p>Amazon has been aware of this limitation and therefore supports an alternative approach called <a href="http://docs.aws.amazon.com/AmazonS3/latest/dev/uploadobjusingmpu.html">Multipart Uploads</a>:</p>

<blockquote>
  <p>Multipart upload allows you to upload a single object as a set of parts. Each part is a contiguous portion of the object's data. You can upload these object parts independently and in any order. If transmission of any part fails, you can retransmit that part without affecting other parts. After all parts of your object are uploaded, Amazon S3 assembles these parts and creates the object.</p>
</blockquote>

<p>This approach is very similar to tus' data model described above and it provides a solid foundation to build an implementation upon. However, development would not be called development if it were as easy as mapping a tus upload one-to-one to a multipart upload. The issue is that Amazon sets <a href="http://docs.aws.amazon.com/AmazonS3/latest/dev/qfacts.html">certain restrictions</a>, the most notable of which is that the minimum size of a single part is limited to 5MB. The only exception to this rule is the last part, which can be smaller. It should be mentioned here that S3 will not complain when you upload a part that is smaller than 5MB, but only when you attempt to finish the multipart upload that does the actual assembly (it will then present you with the <code>EntityTooSmall</code> error message).</p>

<p>The solution - if you want to call it one - is to only upload parts to S3 that match or exceed the minimum size. The storage back-end for tusd achieves this by writing the body of an incoming <code>PATCH</code> request to a temporary file. Once the upload from the user to our tus server reaches a size of 5MB, we are sure that we have enough data for a single part on S3 and can start moving this chunk to Amazon's service. If the tus server does not receive enough data - ensuring, of course, that it is not the last part, which is allowed to be smaller - it will simply drop the temporarily stored file and require the user to attempt a resume, in the hope that the connection is then more reliable. A look at the <a href="https://github.com/tus/tusd/blob/bbf706622c7c5234844fbf2b8c5efdbcda1e3861/s3store/s3store.go#L209-L229">code</a> that powers the implementation described above, may help to understand this.</p>

<p>Regrettably, this approach comes with one noticeable downside for the end user: if an upload or resume is interrupted before at least 5MB has reached the tus server, the sent data will be lost and must be retransmitted. Some may ask why we don't simply locally store the received chunk of data on the tus server, wait for the user to resume the upload and then, once we have enough data, push it to S3. This is certainly a good question, but that solution only works when you can ensure that the resumed request reaches the same tus server as the previously interrupted request. If you are running more than a single tus instance, a special routing mechanism may be required to achieve this. Another option would be to use a second storage medium, such as a shared volume, but that would also need to handle concurrent access correctly.</p>

<p>If this workaround is not acceptable for your application because you do not want to limit the chunks to 5MB, you may want to reconsider using AWS S3 as a storage back-end, since it simply does not offer the required functionality. However, if you are using an alternative back-end that just exposes an S3-compatible API, it may offer a configuration option to change the minimum size of a single part. Riak CS (Cloud Storage), for example, accepts the <a href="https://github.com/basho/riak_cs/blob/c0c1012d1c9c691c74c8c5d9f69d388f5047bcd2/src/riak_cs_config.erl#L191-L193"><code>enforce_multipart_part_size</code> flag</a>, which can entirely remove this constraint.</p>

<h2 id="s3s-eventual-consistency-model">S3's eventual consistency model</h2>

<p>Amazon's engineers wanted to provide a highly available service and were therefore unable to offer guaranteed consistency for every operation. They nevertheless do not hide this important property of S3 and instead describe it extensively in their <a href="http://docs.aws.amazon.com/AmazonS3/latest/dev/Introduction.html#ConsistencyModel">documentation</a>. The most interesting sentence for us, the implementers of tus servers, is the following one:</p>

<blockquote>
  <p>Amazon S3 does not currently support object locking. If two PUT requests are simultaneously made to the same key, the request with the latest time stamp wins. If this is an issue, you will need to build an object-locking mechanism into your application.</p>
</blockquote>

<p>Locking uploads is an important mechanism to prevent data corruption and tus is not immune to it. Imagine a situation where two clients attempt to resume the same upload at the same offset. If the server simply accepts both requests, the latter one may override the data from the first request, resulting in file corruption or loss. In order to prevent this issue, the server needs to acquire an exclusive lock, e.g. a simple <a href="https://en.wikipedia.org/wiki/Semaphore_%28programming%29">semaphore</a>, on the upload resource before it starts transferring the data and then only release that lock once the data is saved. In this scenario, the server will reject the second request from the client, because a lock cannot be obtained when one is already held.</p>

<p>Implementing a proper locking mechanism is, however, difficult and gets even more complicated if you are working in an environment with multiple distributed servers. In this case, a service should be used that manages distributed locks while at the same time guaranteeing consistency. For example, proven technologies include <a href="https://zookeeper.apache.org/doc/r3.1.2/recipes.html#sc_recipes_Locks">ZooKeeper</a> or <a href="https://www.consul.io/docs/commands/lock.html">Consul</a>, but not AWS S3 as it does not offer absolute consistency. Since they do promise "read-after-write consistency for PUTS of new objects in your S3 bucket [but only] eventual consistency for overwrite PUTS and DELETES", this cannot be used to build a distributed lock upon. Therefore, you are recommended to use a third-party system for doing so.</p>

<p>Another option for preventing concurrent uploading is to put the responsibility on the client's side by saying it is their task to prevent multiple accesses to the same upload resource. While this may work, this approach is not able to guarantee corruption-free uploads since a client still might send two or even more requests at the same time by accident and the server does not prevent that.</p>

<h2 id="finishing-thoughts">Finishing Thoughts</h2>

<p>With S3, engineers have an incredibly useful tool for storing data with high availability and scalability. However, it does not present the perfect storage back-end for the tus protocol and requires some workarounds. In the future, we will have a look at other storage system and cloud providers.</p>]]></content><author><name>Marius Kleidl</name><email>marius@transloadit.com</email></author><summary type="html"><![CDATA[With their Simple Storage System (S3), Amazon Web Services has built one of the major providers of cloud storage for applications ranging from small side projects to enterprise systems. Since the introduction of flexible storage back-ends for the official tusd server, an integration with S3 has been a much desired feature by our users. We are happy to announce that we are now able to deliver on this request. During the time it took to create this, we had to deal with various peculiarities of Amazon's service and were able to gain a lot of experience. In this post, we want to focus on the downsides of building a tus server on top of S3 and share some of our recently acquired knowledge with you.]]></summary></entry><entry><title type="html">tus 1.0 - Changing the future of file uploading</title><link href="https://tus.io/blog/2015/11/16/tus.1.0.html" rel="alternate" type="text/html" title="tus 1.0 - Changing the future of file uploading" /><published>2015-11-16T00:00:00+01:00</published><updated>2015-11-16T00:00:00+01:00</updated><id>https://tus.io/blog/2015/11/16/tus.1.0</id><content type="html" xml:base="https://tus.io/blog/2015/11/16/tus.1.0.html"><![CDATA[<p>As time progresses, we share ever larger media files from our phones and desktops. More than often, however, complications arise during this process. Whether it is through servers misbehaving or mobile users switching to a WiFi connection, the outcome is the same: 'upload interrupted'.</p>

<!--more-->

<p>This is by itself a negative user experience, but it becomes even worse when it happens in the middle of a 2GB upload on a slow connection. And of course, the longer an upload takes, the more exposed it is to poor connections. A failed upload will then have to be retried from the start, if the user even bothers with it at all.</p>

<p>With media files growing larger and networks remaining fragile, it is clear that we need a better solution to handle uploading.</p>

<h3 id="resumable-uploads">Resumable Uploads</h3>

<p>Even though certain decent network libraries already implement retries, these do not give the option to resume at the point where the upload was previously interrupted and then only transfer the remaining bytes. Furthermore, these network libraries often require additional user input in order to retry failed uploads. If retries were initiated behind the scenes, the user might not even notice he had an interrupted connection, as the total duration of the upload would barely be impacted.</p>

<p>There are also many areas in the world where connections are quite poor. In such places, restarting an upload from the beginning usually means that the user only gets to transmit the first 20% of his file, before the connection breaks again. Thus, resuming an upload exactly where it left off is the <em>only</em> way a large file will ever be uploaded in these cases.</p>

<p>From this, it is apparent that we <em>need</em> resumable uploads and therefore we are proud to present tus, the protocol that aims to offer solutions to all of the problems listed above.</p>

<p>In addition to this, tus has redesigned the process of uploading in such a way that multiple file parts can be sent simultaneously. Using tus not only makes uploading a lot more reliable, but also much faster.</p>

<h3 id="havent-other-companies-already-implemented-this">Haven't other companies already implemented this?</h3>

<p>Yes, but we see this as another part of the problem. While there are many implementations that offer resumable uploads, they all solve it in a different way. They are either bound to one language or use case. They are also not as thorough or interoperable as we would like, because they all speak different dialects. Some implementations are supported by others, but that is as far as compatibility goes.</p>

<p>This is not remotely how an <em>open web</em> should work.</p>

<p>Dropbox, Vimeo, Google and AWS all have their own API's for uploading chunks. Some companies describe their API, but make choices that aren't suitable for general use and they certainly don't offer a platform to contribute improvements. If we want to support anything beyond their use case, we are on our own again. This further increases fragmentation and leaves resumable file uploads as a luxury, only to be enjoyed by a few large companies, while it should be the standard method that benefits everyone.</p>

<h3 id="tus">tus</h3>

<p>tus is a protocol that is fully community-owned. It has been <a href="https://github.com/tus/tus-resumable-upload-protocol">developed</a> using nothing but GitHub and Markdown, and was fueled by a profound motivation - shared by a few passionate high profile developers - to solve this problem once and for all.</p>

<p>Over the course of two years, we have received suggestions from people working at
<a href="https://github.com/tus/tus-resumable-upload-protocol/issues?q=mentions%3Avayam">Vimeo</a>,
<a href="https://github.com/tus/tus-resumable-upload-protocol/issues?q=mentions%3Atechnoweenie">GitHub</a>,
<a href="https://github.com/tus/tus-resumable-upload-protocol/issues?q=mentions%3ABaughn">Google</a>,
and from the author of
<a href="https://github.com/tus/tus.io/issues?q=mentions%3Ahintjens">ØMQ</a>, as well as from the co-authors of
<a href="https://github.com/tus/tus-resumable-upload-protocol/issues?q=mentions%3Areschke">HTTP/1.1</a> and
<a href="https://github.com/tus/tus-resumable-upload-protocol/issues?q=mentions%3Afelixge">Node.js</a>.</p>

<p>It has not always been easy to find consensus and at times we hit deadlocks. In the past few months, however, we have made considerable progress and we are now excited to announce a finalized version 1.0. tus is ready for the world to use.</p>

<h3 id="how-does-it-work">How does it work?</h3>

<p>Let's take a quick look at an example of a simple communication between a client and a server speaking tus 1.0:</p>

<pre><code class="language-bash"># Client:
&gt; POST /files HTTP/1.1
&gt; Host: tus.example.org
&gt; Tus-Resumable: 1.0.0
&gt; Content-Length: 0
&gt; Upload-Length: 100
&gt; Upload-Metadata: filename d29ybGRfZG9taW5hdGlvbl9wbGFuLnBkZg==

# Server:
&lt; HTTP/1.1 201 Created
&lt; Location: http://tus.example.org/files/24e533e02ec3bc40c387f1a0e460e216
&lt; Tus-Resumable: 1.0.0

# Client:
&gt; PATCH /files/24e533e02ec3bc40c387f1a0e460e216 HTTP/1.1
&gt; Host: tus.example.org
&lt; Tus-Resumable: 1.0.0
&gt; Content-Type: application/offset+octet-stream
&gt; Content-Length: 30
&gt; Upload-Offset: 0
&gt;
&gt; [first 30 bytes]

# Server:
&lt; HTTP/1.1 204 No Content
&lt; Tus-Resumable: 1.0.0
</code></pre>

<p>Since tus is a layer on top of HTTP, it is easy to reason about, inspect, extend and deploy in existing projects as well as infra.</p>

<h3 id="a-streamlined-core-with-optional-extensions">A streamlined core with optional extensions</h3>

<p>The core of the protocol is lightweight, yet well documented and it defines the way in which communication should take place. In addition to this, tus offers extensions such as Checksum, Expiration and Concatenation, which support different use cases and are opt-in.</p>

<p>To highlight one of the protocol's extensions: Concatenation allows you to split a 100GB file in 20 parts of 5GB, upload them in parallel, and uses the tus server to stitch them together again. This makes uploads much faster by utilizing the available bandwidth more efficiently. An extra advantage of this method is that individual chunks are considered regular tus uploads, which benefit from all of tus' features (retries, checksums, etc.).</p>

<h3 id="implementations">Implementations</h3>

<p>Our aim is to support all major languages and platforms. Alongside the protocol
we also develop many implementations, so that developers can have drop-in self-hosted resumable
file uploads at zero cost.</p>

<p>We currently support the following platforms:</p>

<ul>
  <li><a href="https://github.com/tus/tusd">Server in Go</a></li>
  <li><a href="https://github.com/tus/tus-node-server">Server in ES2015 JavaScript for Node.js</a></li>
  <li><a href="https://github.com/tus/tus-js-client">Client in JavaScript</a></li>
  <li><a href="https://github.com/tus/TUSKit">Client for iOS</a></li>
  <li><a href="https://github.com/tus/tus-android-client">Client for Android</a></li>
  <li><a href="https://github.com/tus/tus-java-client">Client in Java</a></li>
</ul>

<p>Additionally, there are many community provided <a href="/implementations.html">implementations</a> in languages such as:
<a href="https://github.com/picocandy/rubytus">Ruby</a>,
<a href="https://github.com/vayam/tuspy">Python</a> and
<a href="https://github.com/leblanc-simon/php-tus">PHP</a>.</p>

<p>Quality implementations of the protocol licensed MIT might be adopted in the <a href="https://github.com/tus">tus organization on GitHub</a>, making you an official contributor to the project.</p>

<h3 id="releasing-version-10">Releasing version 1.0</h3>

<p>Today we are proud to announce that we have launched version 1.0 on GitHub by merging <a href="https://github.com/tus/tus-resumable-upload-protocol/pull/57">the 1.0 pull request</a>.</p>

<p>We consider the protocol to be stable and ready for production!</p>

<p>The full protocol is published online <a href="/protocols/resumable-upload.html">here</a>.</p>

<h3 id="early-adopters">Early Adopters</h3>

<p>Early adopters <a href="https://vimeo.com">Vimeo</a> and Transloadit have already announced they will use tus 1.0 as their main protocol for uploading.</p>

<p>tus is initiated and funded by <a href="https://transloadit.com">Transloadit</a>, but it is community owned and this will never change.</p>

<p>We encourage anybody who deals with file uploads to have have a look at tus and to consider using it for your next release.</p>

<h3 id="special-thanks">Special Thanks</h3>

<p>It has taken us the better part of three years and we have had to overcome many obstacles along the way. It is in great part thanks to <a href="/about.html">these people</a> that tus is able to push out a stable release today. A special 
word of thanks goes out to the talented people that have been instrumental in getting us to where we are today: <a href="https://felixge.de">Felix</a>, <a href="https://github.com/vayam">Naren</a> and <a href="https://transloadit.com/about#marius">Marius</a>. We couldn't have done tus without you!</p>

<p>Discuss on <a href="https://news.ycombinator.com/item?id=10574364">Hacker News</a></p>]]></content><author><name>Kevin van Zonneveld</name><email>kevin@transloadit.com</email></author><summary type="html"><![CDATA[As time progresses, we share ever larger media files from our phones and desktops. More than often, however, complications arise during this process. Whether it is through servers misbehaving or mobile users switching to a WiFi connection, the outcome is the same: 'upload interrupted'.]]></summary></entry></feed>